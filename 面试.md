# js 基础
### 1. 闭包
一句话：**闭包**是有权访问其他函数内部变量的函数。

问题：为什么非闭包不能访问？什么是作用域？

答： 由于在js中函数执行完，作用域便会销毁，内存回收，但是由于闭包是建立在一个函数内部的子函数，可以访问上级作用域，所以不会被销毁。
[https://zhuanlan.zhihu.com/p/29157822](https://zhuanlan.zhihu.com/p/29157822)

### 2. new操作符做了什么

1. 创建一个空对象，o = new Object().
2. 这个对象的原型指针指向构造函数的原型，o.__proto__ = F.prototype.
3. 更改作用域，F.call(o)

### 3. es5继承（那些方式）
> -- from 《js设计模式》 张容铭
1. 类式继承
```
// 子类(A)的原型指向父类(B)的实例。
A.prototype = new B()
// 缺点： 如果父类原型有属性是引用类型，则其中一个子类更改类会影响其他子类
```
2. 构造函数继承
```
// 在子类里调用父类（构造函数）
function A(){
  B.call(this, args)
}
// 缺点： 父类原型不会被子类继承。
```
3. 组合继承
```
// 在2.构造函数继承基础上加上1.类继承
A.prototype = new B()
// 缺点： 多次调用父类构造函数。
```
4. 原型示继承
// 借助一个函数，该函数返回一个匿名实例
function inherit(o) {
  function F(){}
  F.prototype = o
  return new F()
}
// 缺点： 和1.类继承一样
5. 终极模式
```
function inherit(o) {
  function F(){}
  F.prototype = o
  return new F()
}

function extend(Sub, Sup) {
  // 复制一份父类的原型副本保存在变量中，
  var p = inherit(Sup.prototype)
  // 修正因为重写子类导致子类的constructor属性被修改。
  p.constructor = Sub
  Sub.prototype = p
}

// 使用
extend(A, B)
```
### 4. 0.2+0.1不等于0.3问题
- 对于单精度浮点数，采用32位存储，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
- 对于双精度浮点数，采用64位存储，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

单精度指数范围是-126 ～ +127，双精度是 -1022 ～ +1023，

浮点转化为而进制，整数部分采用除2取余，小数部分采用乘2取整。
eg: 13.125 --> 1011.001 = 1.011001 * 2^3, M为 1.011001,E为3,s为0

e=E+127，即e=3+127=130，130的二进制表示为10000010
0  10000010  01100100000000000000000

**因为1<=M<2**,所以M第一位总是等于1，省略。

0.1 --> 0.0001100110011(0011循环) = 1.100110011(0011)*2^-4
s=0; e= -4+1023=1019, M=1.100110011(0011)
0.2 --> 0.001100110011(0011循环) = 1.100110011(0011)*2^-3

> 该数表示的即0.1+0.2的结果 2^-2 * 1.0011001100110011001100110011001100110011001100110100<br>
> 将其转换成十进制数为：0.3000000000000000444089209850062616169452667236328125<br/>
> 由于精度问题，只取到0.30000000000000004

[参考链接：http://coolcao.com/2016/10/12/js%E4%B8%AD0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/](http://coolcao.com/2016/10/12/js%E4%B8%AD0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/)