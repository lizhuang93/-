## 1. webpack3、4比较
type | webpack3及以下 | webpack4 | 说明 
---|---|---|---
plugin | ExtractTextPlugin | MiniCssExtractPlugin<br>（优点：1. 异步加载，2. 没有重复的编译（性能），3. 更容易使用， 4. 特定于CSS） | 将CSS提取到单独的文件中,用于长期缓存。
&nbsp; | CommonChunkPlugin | SplitChunksPlugin |webpack 内置 optimization.splitChunks|
&nbsp; | webpack.DefinePlugin等 | mode 已含有

## 2. webpack 加快打包速度

- 搜索时间：
  缩小文件搜索范围(test 、 include 、 exclude、resolve.extensions 列表要尽可能的小) ;
  减小不必要的编译工作: module.noParse: /jquery/
- 解析时间：
  对一些性能开销较大loader，使用thread-loader(happypack已不在维护)，cache-loader。
- 压缩时间：
  terser-webpack-plugin 启动多进程压缩。
- 二次打包时间
  dllPlugin,配合 externals 使用。

```
module.exports = {
  module: {
    // 忽略大型的 library 可以提高构建性能
    noParse: /jquery|lodash/
  },
  devtool: {
    isDev ? 'eval-source-map' : false
  },
  // 防止将某些 import 的包(package)打包到 bundle 中
  externals: /^(jquery|\$)$/i,
  // 排除 node_modules 的转译；transform-runtime 减少冗余代码, 防止重复注入。
  {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          // 也可使用.babelrc配置文件
          options: {
            presets: ['env'],
            plugins: ['transform-runtime']
          }
        }
      },
}
```
## 3. webpack 动态加载原理
编译后主js文件了里定义里全局的installChunks对象，和私有的promise数组。installChunks用来记录是否加载完成和加载中，
- 加载完成 return promise.all([])；
- 加载中则存储文件对应的promise；
- 没有加载则动态script src 加载js并将promise放入promise数组，installChunks中保存resolve、reject。
- 在0.js中改变installChunks['0.js'] = 0和执行resolve。

## 4. webpack 原理、构建流程
> 根据配置参数对complier、plugin等进行初始化，然后执行run方法，从入口开始递归每个模块，通过loader进行翻译，生成翻译后的模块及依赖关系，根据依赖关系生成chunk，再把生成输出文件列表，最后生成文件。在以上过程中，webpack 会广播事件，然后plugin根据监听的事件执行对应的操作。

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
- 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。
## 5. 如何利用webpack来优化前端性能
压缩代码、利用CDN加速、删除死代码（Tree Shaking）、提取公共代码

## 6. 如何编写 webpack plugin
- Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息。
- Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。<br>
Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。
## 7. webpack 热更新
1. 使用express启动本地服务，当浏览器访问资源时对此做响应。
2. 服务端和客户端使用websocket实现长连接。
3. webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。
   1. 每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件
   2. 编译完成后通过socket向客户端推送当前编译的hash戳
4. 客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比
   1. 一致则走缓存
   2. 不一致则通过ajax和jsonp向服务端获取最新资源
5. 使用内存文件系统去替换有修改的内容实现局部刷新